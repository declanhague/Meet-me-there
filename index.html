<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeetMeThere (OSRM Encoding Reinstated)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet for Maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        
        /* Prominent Map Styles */
        #map-container { 
            height: 50vh; 
            min-height: 400px; 
            width: 100%; 
            border-radius: 1rem; 
            z-index: 1; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        /* Mobile optimization for map height */
        @media (min-width: 1024px) {
            #map-container { height: 100%; min-height: 600px; }
        }

        .spinner {
            border: 3px solid rgba(200, 200, 200, 0.3);
            border-top: 3px solid #4f46e5;
            border-radius: 50%;
            width: 16px; height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Status Icon alignment */
        .status-wrapper { width: 24px; display: flex; justify-content: center; }

        /* Debug Log Panel Styling */
        #debug-panel {
            position: fixed;
            bottom: 60px;
            left: 20px;
            width: 350px;
            max-width: 90vw;
            height: 300px;
            background-color: #1f2937; /* Dark background */
            color: #d1d5db; /* Light gray text */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            flex-direction: column;
        }
        #debug-panel.active { display: flex; }
        #debug-log-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0.5rem;
            font-size: 0.75rem;
            font-family: monospace;
            line-height: 1.3;
        }
        .log-item-info { color: #9ca3af; }
        .log-item-success { color: #4ade80; }
        .log-item-warning { color: #facc15; }
        .log-item-error { color: #f87171; font-weight: bold; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 h-screen flex flex-col">

    <!-- Top Bar -->
    <header class="bg-white border-b px-6 py-3 flex justify-between items-center shadow-sm z-10">
        <h1 class="text-xl font-extrabold text-indigo-700 flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 10c0 6-8 8-8 8s-8-6-8-8a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></svg>
            MeetMeThere
        </h1>
        <div id="auth-status" class="text-xs font-mono text-gray-400">Guest Session</div>
    </header>

    <!-- Main Content Grid -->
    <div class="flex-grow overflow-hidden">
        <div class="h-full grid grid-cols-1 lg:grid-cols-5">
            
            <!-- LEFT COLUMN: Controls (Scrollable) -->
            <div class="lg:col-span-2 h-full overflow-y-auto p-4 sm:p-6 space-y-6 bg-white shadow-xl z-10">
                
                <!-- 1. Travelers Input -->
                <div class="space-y-3">
                    <h2 class="font-bold text-gray-800 flex items-center gap-2 text-sm uppercase tracking-wide text-indigo-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>
                        Starting Locations
                    </h2>
                    <div id="users-list" class="space-y-2">
                        <!-- User rows injected here -->
                    </div>
                    <button onclick="window.logic.addUser()" class="w-full py-2 border-2 border-dashed border-gray-300 text-gray-500 rounded-lg hover:border-indigo-500 hover:text-indigo-500 text-xs font-bold uppercase transition-colors">
                        + Add Friend
                    </button>
                </div>

                <!-- 2. Filters (Expanded) -->
                <div class="space-y-3">
                    <h2 class="font-bold text-gray-800 flex items-center gap-2 text-sm uppercase tracking-wide text-indigo-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>
                        Looking For...
                    </h2>
                    <div id="filters-container" class="flex flex-wrap gap-2">
                        <!-- Filters injected here -->
                    </div>
                </div>

                <!-- 3. Optimization Mode -->
                <div class="bg-gray-100 p-1 rounded-lg flex text-sm">
                    <button id="btn-mode-total" onclick="window.logic.setMode('total')" class="flex-1 py-2 rounded-md font-medium text-gray-500">Fastest Total</button>
                    <button id="btn-mode-individual" onclick="window.logic.setMode('individual')" class="flex-1 py-2 rounded-md font-medium text-gray-500">Fairness</button>
                </div>

                <!-- 4. Calculate Button -->
                <button id="btn-calculate" onclick="window.logic.runCalculation()" class="w-full py-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold rounded-xl shadow-lg transform transition active:scale-95 flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                    Find Meeting Point
                </button>

                <!-- 5. Results List -->
                <div id="results-container" class="space-y-3 pb-10">
                    <!-- Results injected here -->
                </div>
            </div>

            <!-- RIGHT COLUMN: Map -->
            <div class="lg:col-span-3 h-full relative bg-gray-200">
                <div id="map-container" class="h-full w-full"></div>
                <!-- Map Legend Overlay -->
                <div class="absolute bottom-6 left-6 bg-white/90 backdrop-blur p-3 rounded-lg shadow-md text-xs z-[400] pointer-events-none hidden sm:block">
                    <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 rounded-full bg-blue-600"></span> Traveler</div>
                    <div class="flex items-center gap-2"><span class="w-3 h-3 rounded-full bg-red-600"></span> Venue</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Log Panel -->
    <div id="debug-panel">
        <div class="p-2 flex justify-between items-center border-b border-gray-700">
            <h4 class="text-sm font-semibold text-indigo-400">Live Debug Log</h4>
            <button onclick="window.logic.toggleDebugPanel()" class="text-gray-400 hover:text-white">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </button>
        </div>
        <div id="debug-log-content">
            <!-- Log messages appended here -->
        </div>
    </div>
    
    <!-- Debug Toggle Button -->
    <button id="debug-toggle-btn" onclick="window.logic.toggleDebugPanel()" class="fixed bottom-4 left-4 p-3 bg-indigo-600 text-white rounded-full shadow-lg hover:bg-indigo-700 z-50 transition transform active:scale-95" title="Toggle Debug Log">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20V10"/><path d="M12 4h.01"/><path d="M19.39 6.75l-1.32 1.32"/><path d="M4.61 6.75l1.32 1.32"/><path d="M21.05 13.91l-1.91.56"/><path d="M3.95 13.91l1.91.56"/><path d="M19 18v1"/><path d="M5 18v1"/></svg>
    </button>


    <!-- LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURATION ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- EXTERNAL API ENDPOINTS (These are the correct APIs and will now work on your live server) ---
        const OVERPASS_API = "https://overpass-api.de/api/interpreter";
        const OSRM_API_BASE = "https://router.project-osrm.org/table/v1"; // Correct base for /table service
        
        // Gemini Config (Used for reliable geocoding of user-entered addresses)
        const GEMINI_API_KEY = ""; 
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
        const MAX_RETRIES = 3;
        const INITIAL_BACKOFF_MS = 1000;


        // POI Definitions
        const POI_TYPES = [
            { id: 'pub', label: 'Pub', tag: 'pub' },
            { id: 'cafe', label: 'Cafe', tag: 'cafe' },
            { id: 'restaurant', label: 'Restaurant', tag: 'restaurant' },
            { id: 'bar', label: 'Bar', tag: 'bar' },
            { id: 'cinema', label: 'Cinema', tag: 'cinema' },
            { id: 'shopping', label: 'Shopping Mall', tag: 'shopping_mall' },
            { id: 'park', label: 'Greenspace', tag: 'park' },
            { id: 'bowling', label: 'Bowling Alley', tag: 'bowling_alley' },
            { id: 'theater', label: 'Theater', tag: 'theatre' },
            { id: 'nightclub', label: 'Nightclub', tag: 'nightclub' }
        ];
        
        // HARDCODED FALLBACK COORDINATES (For initial map display only)
        const HARDCODED_COORDS = {
            'WARE, UK': { lat: 51.8105, lng: -0.0354 },
            'SG12 9LS, UK': { lat: 51.7963, lng: -0.0416 }
        };

        // --- STATE ---
        const state = {
            users: [
                { id: 1, location: 'Ware, UK', transport: 'Driving', coords: null, status: 'init' },
                { id: 2, location: 'SG12 9LS, UK', transport: 'Driving', coords: null, status: 'init' }
            ],
            filters: ['pub'], 
            optMode: 'individual',
            results: [],
            userId: 'guest',
            isProcessing: false,
            appLogs: [], // New state for live logs
            isDebugPanelOpen: false, // New state for panel visibility
        };

        // --- GLOBALS ---
        let db, auth, map, markersLayer;
        let debounceTimer;

        // --- INIT ---
        async function init() {
            logMessage('info', "App Initializing...");
            // 1. Map
            initMap();

            // 2. Firebase
            if (Object.keys(firebaseConfig).length > 0) {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                try { 
                    const signin = initialAuthToken ? signInWithCustomToken(auth, initialAuthToken) : signInAnonymously(auth);
                    await signin;
                    logMessage('success', "Firebase Auth successful.");
                } catch (e) {
                    logMessage('error', `Firebase Auth failed: ${e.message}`);
                }
                
                onAuthStateChanged(auth, (u) => {
                    if (u) {
                        state.userId = u.uid;
                        document.getElementById('auth-status').innerText = 'Synced';
                        setupSync();
                    }
                });
            }

            // 3. Initial Render
            renderUserList();
            renderFilters();
            renderModeButtons();

            // 4. Resolve initial locations
            logMessage('info', "Starting initial location resolution...");
            const resolutionPromises = state.users.map(u => resolveLocation(u.id, u.location, false));
            await Promise.all(resolutionPromises);
            
            // 5. Final UI/Map update 
            updateMapMarkers();
            logMessage('success', "Initial state loaded.");
        }

        // --- UTILITIES ---
        const delay = ms => new Promise(res => setTimeout(res, ms));

        function getStatusHTML(user) {
            const baseClasses = "text-xs font-semibold px-2 py-0.5 rounded-full";
            if (user.status === 'searching') return `<div class="status-wrapper"><span class="${baseClasses} bg-indigo-100 text-indigo-700 flex items-center gap-1"><div class="spinner w-3 h-3"></div> Searching...</span></div>`;
            if (user.status === 'found') return `<div class="status-wrapper"><span class="${baseClasses} bg-green-100 text-green-700">Success</span></div>`;
            if (user.status === 'error') return `<div class="status-wrapper"><span class="${baseClasses} bg-red-100 text-red-700 cursor-help" title="Location not found. Try 'City, Country' or 'Lat, Lng' format.">Error</span></div>`;
            return `<div class="status-wrapper"><span class="${baseClasses} bg-gray-100 text-gray-500">Waiting</span></div>`;
        }

        function calculateCentroid(coords) {
            const numPoints = coords.length;
            const avgLat = coords.reduce((sum, c) => sum + c.lat, 0) / numPoints;
            const avgLng = coords.reduce((sum, c) => sum + c.lng, 0) / numPoints;
            return { lat: avgLat, lng: avgLng };
        }

        // --- LIVE LOGGING ---
        function logMessage(type, message) {
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, second: '2-digit', minute: '2-digit' });
            const logItem = { timestamp, type, message };
            state.appLogs.push(logItem);
            // Limit log size to prevent memory issues
            if (state.appLogs.length > 50) state.appLogs.shift(); 

            // Log to console as well for full debug context
            if (type === 'error') console.error(`[${timestamp}] [UI LOG] ${message}`);
            else if (type === 'warning') console.warn(`[${timestamp}] [UI LOG] ${message}`);
            else console.log(`[${timestamp}] [UI LOG] ${message}`);

            if (state.isDebugPanelOpen) renderLogs();
        }

        function renderLogs() {
            const container = document.getElementById('debug-log-content');
            if (!container) return;
            
            container.innerHTML = state.appLogs.map(log => {
                let colorClass;
                let prefix;
                switch(log.type) {
                    case 'error': colorClass = 'log-item-error'; prefix = '❌ ERROR:'; break;
                    case 'warning': colorClass = 'log-item-warning'; prefix = '⚠️ WARN:'; break;
                    case 'success': colorClass = 'log-item-success'; prefix = '✅ SUCCESS:'; break;
                    default: colorClass = 'log-item-info'; prefix = 'ℹ️ INFO:';
                }
                return `<div class="${colorClass}">[${log.timestamp}] ${prefix} ${log.message}</div>`;
            }).join('');

            container.scrollTop = container.scrollHeight; // Scroll to bottom
        }

        // --- UI RENDERERS ---
        function renderUserList() {
            const container = document.getElementById('users-list');
            container.innerHTML = state.users.map((u, idx) => `
                <div class="flex items-center gap-3 bg-white p-3 rounded-xl border border-gray-200 shadow-sm transition-all focus-within:ring-2 focus-within:ring-indigo-500" id="user-row-${u.id}">
                    <div class="w-8 h-8 flex-shrink-0 rounded-full bg-indigo-100 text-indigo-600 flex items-center justify-center font-bold text-sm shadow-sm">${idx + 1}</div>
                    
                    <div class="flex-grow">
                        <input type="text" 
                            value="${u.location}" 
                            oninput="window.logic.handleInput(${u.id}, this.value)"
                            class="w-full bg-transparent text-sm font-medium text-gray-800 placeholder-gray-400 outline-none"
                            placeholder="City, Postcode, or Lat, Lng">
                    </div>

                    <div id="status-${u.id}" class="flex-shrink-0 w-24 text-right">
                        ${getStatusHTML(u)}
                    </div>
                    
                    <div class="h-6 w-px bg-gray-200 mx-1"></div>

                    <select onchange="window.logic.handleTransport(${u.id}, this.value)" class="text-xs font-medium text-gray-500 bg-transparent outline-none cursor-pointer flex-shrink-0">
                        <option value="Driving" ${u.transport==='Driving'?'selected':''}>Car</option>
                        <option value="Cycling" ${u.transport==='Cycling'?'selected':''}>Bike</option>
                        <option value="Walking" ${u.transport==='Walking'?'selected':''}>Walk</option>
                    </select>

                    <button onclick="window.logic.removeUser(${u.id})" class="text-gray-300 hover:text-red-500 transition-colors pl-1 flex-shrink-0">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    </button>
                </div>
            `).join('');
        }

        function updateUserStatusUI(id) {
            const el = document.getElementById(`status-${id}`);
            const user = state.users.find(u => u.id === id);
            if (el && user) el.innerHTML = getStatusHTML(user);
        }

        function renderFilters() {
            const container = document.getElementById('filters-container');
            container.innerHTML = POI_TYPES.map(f => `
                <button onclick="window.logic.toggleFilter('${f.tag}')" 
                    class="text-xs px-3 py-1.5 rounded-lg border font-medium transition-all active:scale-95 ${state.filters.includes(f.tag) 
                        ? 'bg-indigo-600 text-white border-indigo-600 shadow-md' 
                        : 'bg-white text-gray-600 border-gray-200 hover:border-indigo-300 hover:text-indigo-600'}">
                    ${f.label}
                </button>
            `).join('');
        }

        function renderModeButtons() {
            const tBtn = document.getElementById('btn-mode-total');
            const iBtn = document.getElementById('btn-mode-individual');
            const activeClass = 'bg-white text-indigo-600 shadow-sm ring-1 ring-gray-200';
            const inactiveClass = 'text-gray-400 hover:text-gray-600';
            
            tBtn.className = `flex-1 py-2 rounded-md font-medium transition-all ${state.optMode === 'total' ? activeClass : inactiveClass}`;
            iBtn.className = `flex-1 py-2 rounded-md font-medium transition-all ${state.optMode === 'individual' ? activeClass : inactiveClass}`;
        }

        function renderResults() {
            const container = document.getElementById('results-container');
            
            if (state.isProcessing) {
                container.innerHTML = `<div class="p-10 text-center text-gray-500 animate-pulse flex flex-col items-center"><div class="spinner w-8 h-8 mb-3"></div>Fetching Locations and Routing Data...</div>`;
                return;
            }
            if (state.results.length === 0 && !state.isProcessing) {
                 container.innerHTML = `<div class="p-4 bg-yellow-100 text-yellow-800 rounded-lg text-sm font-medium">No results found. Try refining your location inputs or search filters. (Check Debug Log for API Errors)</div>`;
                 return;
            }
            
            container.innerHTML = `<h3 class="font-bold text-gray-700 text-sm uppercase tracking-wide mt-4 mb-2">Best Meeting Points</h3>` + 
            state.results.map((r, i) => `
                <div class="bg-white p-4 rounded-xl border border-gray-100 shadow-sm hover:shadow-md transition-shadow cursor-pointer group" onclick="window.logic.focusMapOnResult(${r.lat},${r.lng})">
                    <div class="flex justify-between items-start">
                        <div>
                            <div class="flex items-center gap-2">
                                <span class="bg-red-500 text-white text-[10px] font-bold px-1.5 py-0.5 rounded-md">#${i+1}</span>
                                <h3 class="font-bold text-gray-800 group-hover:text-indigo-600 transition-colors">${r.name}</h3>
                            </div>
                            <p class="text-xs text-gray-500 mt-0.5">${r.category}</p>
                        </div>
                        <div class="text-right">
                            <div class="text-lg font-black text-indigo-600 leading-tight">${state.optMode==='total' ? r.totalTime : r.maxIndividualTime}<span class="text-xs font-normal text-gray-400 ml-0.5">min</span></div>
                        </div>
                    </div>
                    <div class="mt-3 flex flex-wrap gap-2">
                        ${state.users.filter(u => u.coords).map(u => {
                            const time = r.travelTimes[u.id];
                            return `<span class="text-[10px] bg-gray-50 text-gray-500 px-2 py-1 rounded border border-gray-100">
                                ${u.location.split(',')[0]}: <b>${time}m</b>
                            </span>`;
                        }).join('')}
                    </div>
                </div>
            `).join('');
            
            updateMapMarkers();
        }

        // --- MAP LOGIC ---
        function initMap() {
            if (map) return;
            map = L.map('map-container', { zoomControl: false }).setView([54.5, -4], 6);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap &copy; CARTO',
                maxZoom: 19
            }).addTo(map);
            markersLayer = L.layerGroup().addTo(map);
            L.control.zoom({ position: 'bottomright' }).addTo(map);
        }

        function updateMapMarkers() {
            if (!map || !markersLayer) return;
            markersLayer.clearLayers();
            const bounds = L.latLngBounds();
            let hasPoints = false;

            // Users (Blue)
            state.users.forEach((u, i) => {
                if (u.coords) {
                    const icon = L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background:#4f46e5; color:white; width:28px; height:28px; border-radius:50%; border:3px solid white; display:flex; align-items:center; justify-content:center; font-weight:bold; box-size:12px;">${i+1}</div>`,
                        iconSize: [28, 28], iconAnchor: [14, 14]
                    });
                    L.marker([u.coords.lat, u.coords.lng], { icon }).addTo(markersLayer).bindPopup(`<b>Traveler ${i+1}</b><br>${u.location}`);
                    bounds.extend([u.coords.lat, u.coords.lng]);
                    hasPoints = true;
                }
            });

            // Results (Red)
            if (state.results.length > 0) {
                state.results.forEach((r, i) => {
                    // Coordinates come directly from Overpass/OSRM in this architecture
                    if (r.lat && r.lng) {
                        const icon = L.divIcon({
                            className: 'custom-marker',
                            html: `<div style="background:#ef4444; color:white; width:24px; height:24px; border-radius:50%; border:2px solid white; display:flex; align-items:center; justify-content:center; font-weight:bold; box-size:10px;">${i+1}</div>`,
                            iconSize: [24, 24], iconAnchor: [12, 12]
                        });
                        L.marker([r.lat, r.lng], { icon }).addTo(markersLayer).bindPopup(`<b>#${i+1} ${r.name}</b><br>${state.optMode === 'total' ? r.totalTime : r.maxIndividualTime} min`);
                        bounds.extend([r.lat, r.lng]);
                        hasPoints = true;
                    }
                });
            }

            if (hasPoints) map.fitBounds(bounds, { padding: [80, 80], maxZoom: 14, animate: true });
        }

        // --- LOGIC ENGINE ---
        window.logic = {
            toggleDebugPanel: () => {
                state.isDebugPanelOpen = !state.isDebugPanelOpen;
                const panel = document.getElementById('debug-panel');
                if (state.isDebugPanelOpen) {
                    panel.classList.add('active');
                    renderLogs();
                } else {
                    panel.classList.remove('active');
                }
            },
            handleInput: (id, val) => {
                const u = state.users.find(u => u.id === id);
                if (u) {
                    u.location = val;
                    u.status = 'searching'; 
                    updateUserStatusUI(id);
                    clearTimeout(debounceTimer);
                    
                    debounceTimer = setTimeout(() => {
                        resolveLocation(id, val, true).then(() => updateMapMarkers()); 
                    }, 1000); // Increased debounce for stability
                }
            },
            
            handleTransport: (id, val) => {
                const u = state.users.find(u => u.id === id);
                if (u) u.transport = val;
                saveToDB();
            },

            addUser: () => {
                const newId = state.users.length > 0 ? Math.max(...state.users.map(u => u.id)) + 1 : 1;
                state.users.push({ id: newId, location: '', transport: 'Driving', coords: null, status: 'init' });
                renderUserList();
            },

            removeUser: (id) => {
                state.users = state.users.filter(u => u.id !== id);
                renderUserList();
                updateMapMarkers();
                saveToDB();
            },

            toggleFilter: (tag) => {
                if (state.filters.includes(tag)) state.filters = state.filters.filter(t => t !== tag);
                else state.filters.push(tag);
                renderFilters();
                saveToDB();
            },

            setMode: (mode) => {
                state.optMode = mode;
                renderModeButtons();
                saveToDB();
                // Re-sort results instantly based on new mode without recalculating
                if (state.results.length) {
                     state.results.sort((a, b) => state.optMode === 'total' ? a.totalTime - b.totalTime : a.maxIndividualTime - b.maxIndividualTime);
                    renderResults();
                    updateMapMarkers();
                }
            },

            focusMapOnResult: (lat, lng) => {
                map.flyTo([lat, lng], 16, { duration: 1.5 });
            },

            runCalculation: async () => {
                const validUsers = state.users.filter(u => u.coords);
                if (validUsers.length < 2) { 
                    const msg = "Calculation requires at least two locations successfully geocoded.";
                    logMessage('warning', msg);
                    document.getElementById('results-container').innerHTML = `<div class="p-4 bg-yellow-100 text-yellow-800 rounded-lg text-sm font-medium">${msg}</div>`;
                    return; 
                }
                
                state.isProcessing = true;
                renderResults();
                saveToDB();

                try {
                    logMessage('info', "Step 1: Calculating Centroid...");
                    // 1. Calculate Centroid (Midpoint)
                    const userCoords = validUsers.map(u => u.coords);
                    const centroid = calculateCentroid(userCoords);
                    logMessage('success', `Centroid Calculated at: ${centroid.lat.toFixed(4)}, ${centroid.lng.toFixed(4)}`);
                    
                    // 2. Fetch POIs using Overpass
                    logMessage('info', `Step 2: Querying Overpass API for POIs near centroid with filters: ${state.filters.join(', ')}`);
                    const rawPois = await fetchPois(centroid, state.filters);
                    logMessage('success', `Overpass API Success. Found ${rawPois.length} potential POIs.`);

                    if (rawPois.length === 0) {
                         throw new Error("No POIs found near the midpoint with the current filters. Try widening the search.");
                    }
                    
                    // 3. Get Travel Times using OSRM
                    logMessage('info', `Step 3: Calculating travel times for ${rawPois.length} POIs using OSRM API.`);
                    const finalResults = await getTravelTimes(rawPois, validUsers);
                    logMessage('success', `OSRM API Success. Calculated routes for ${finalResults.length} venues.`);
                    
                    // 4. Sort and Store Results
                    finalResults.sort((a, b) => state.optMode === 'total' ? a.totalTime - b.totalTime : a.maxIndividualTime - b.maxIndividualTime);
                    state.results = finalResults.slice(0, 10);

                } catch (e) {
                    logMessage('error', `❌ Major Calculation Failed: OSRM Error: ${e.message}`);
                    state.results = []; // Clear results on hard failure
                    // Provide a specific error message for the live user
                    document.getElementById('results-container').innerHTML = `<div class="p-4 bg-red-100 text-red-800 rounded-lg text-sm font-medium">
                        ❌ Calculation Failed. See the Debug Log for details. Error: ${e.message}
                    </div>`;
                }

                state.isProcessing = false;
                saveToDB();
                renderResults();
            }
        };

        // --- EXTERNAL API FUNCTIONS ---

        function createOverpassQuery(centroid, filters) {
            const bbox_radius = 5000; // 5km radius
            const min_lat = centroid.lat - (bbox_radius / 111111);
            const max_lat = centroid.lat + (bbox_radius / 111111);
            const min_lng = centroid.lng - (bbox_radius / (111111 * Math.cos(centroid.lat * (Math.PI / 180))));
            const max_lng = centroid.lng + (bbox_radius / (111111 * Math.cos(centroid.lat * (Math.PI / 180))));
            const bbox = [min_lat, min_lng, max_lat, max_lng].join(',');

            const filterClauses = filters.map(tag => `node[amenity=${tag}](${bbox});`).join('');

            return `
                [out:json][timeout:25];
                (
                    ${filterClauses}
                );
                out center;
            `;
        }
        
        async function fetchPois(centroid, filters) {
            const query = createOverpassQuery(centroid, filters);
            
            const response = await fetch(OVERPASS_API, {
                method: 'POST',
                body: `data=${encodeURIComponent(query)}`
            });
            
            if (!response.ok) {
                logMessage('error', `Overpass HTTP Error: ${response.status} ${response.statusText}`);
                throw new Error(`Overpass API failed with status ${response.status}`);
            }

            const data = await response.json();
            
            return data.elements
                .filter(el => el.lat && el.lon)
                .map(el => ({
                    name: el.tags.name || `Unnamed ${el.tags.amenity || 'Location'}`,
                    category: el.tags.amenity || 'POI',
                    lat: el.lat,
                    lng: el.lon,
                    id: el.id
                }));
        }

        async function getTravelTimes(pois, users) {
            // Determine OSRM Profile
            const userTransport = users[0].transport;
            let profile;
            if (userTransport === 'Driving') profile = 'driving';
            else if (userTransport === 'Cycling') profile = 'bike';
            else if (userTransport === 'Walking') profile = 'foot';
            else profile = 'driving'; // Default fallback

            // IMPORTANT: OSRM uses Longitude,Latitude (LNG,LAT) format
            // Coordinate lists must be semicolon-separated (;) and URL-encoded.
            const rawSources = users.map(u => `${u.coords.lng},${u.coords.lat}`).join(';');
            const rawDestinations = pois.map(p => `${p.lng},${p.lat}`).join(';');
            
            // Reinstating URL Encoding (The standard, correct way)
            const encodedSources = encodeURIComponent(rawSources);
            const encodedDestinations = encodeURIComponent(rawDestinations);

            // Construct the final URL
            const url = `${OSRM_API_BASE}/${profile}?sources=${encodedSources}&destinations=${encodedDestinations}&annotations=duration`;

            // Detailed Logging for Inspection
            logMessage('info', `OSRM Profile: ${profile}`);
            logMessage('info', `OSRM Raw Sources: ${rawSources}`);
            logMessage('info', `OSRM Encoded Sources: ${encodedSources}`);
            logMessage('info', `OSRM Final URL: ${url}`);


            const response = await fetch(url);
            const data = await response.json();

            if (data.code !== 'Ok') {
                logMessage('error', `OSRM Response Error: ${data.code} - ${data.message}`);
                throw new Error(`${data.code}: ${data.message}. Locations might be unreachable or the URL malformed.`);
            }

            const results = [];
            const durations = data.durations; 

            pois.forEach((poi, poiIndex) => {
                let totalTime = 0;
                let maxIndividualTime = 0;
                const travelTimes = {};
                let isReachable = true;

                users.forEach((user, userIndex) => {
                    // Durations are in seconds
                    const timeInSeconds = durations[userIndex][poiIndex]; 
                    if (timeInSeconds === null) {
                         logMessage('warning', `POI ${poi.name} unreachable from Traveler ${userIndex + 1}. Excluding this POI.`);
                         isReachable = false;
                    }
                    if (isReachable) {
                        const timeInMinutes = Math.ceil(timeInSeconds / 60); 
                        travelTimes[user.id] = timeInMinutes;
                        totalTime += timeInMinutes;
                        if (timeInMinutes > maxIndividualTime) maxIndividualTime = timeInMinutes;
                    }
                });

                if (isReachable) {
                    results.push({
                        ...poi,
                        totalTime,
                        maxIndividualTime,
                        travelTimes
                    });
                }
            });
            
            if (results.length === 0) {
                 throw new Error("All potential POIs were found to be unreachable by at least one traveler.");
            }

            return results;
        }


        // --- GEMINI FETCH HELPERS (Used ONLY for Geocoding) ---
        async function fetchGeminiSimple(payload) {
            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const result = await response.json();
                    let jsonString = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    
                    if (jsonString) {
                        jsonString = jsonString.replace(/```json\n|```/g, '').trim(); 
                        return JSON.parse(jsonString);
                    }
                    throw new Error("Invalid or empty response from LLM.");
                } catch (e) {
                    if (attempt < MAX_RETRIES - 1) {
                        const backoffTime = INITIAL_BACKOFF_MS * Math.pow(2, attempt);
                        logMessage('warning', `Gemini Geocoding retry ${attempt + 1}: backing off for ${backoffTime}ms.`);
                        await delay(backoffTime);
                    } else {
                        throw e; 
                    }
                }
            }
        }
        
        // --- GEOCODING ---
        async function resolveLocation(id, name, save=true) {
            const u = state.users.find(u => u.id === id);
            const normalizedName = name.toUpperCase().trim();

            if (!name) { 
                u.status = 'init'; u.coords = null; updateUserStatusUI(id); if(save) saveToDB(); return; 
            }
            
            // 1. LOCAL COORDINATE FALLBACK (For initial demo coordinates)
            if (HARDCODED_COORDS[normalizedName]) {
                u.coords = HARDCODED_COORDS[normalizedName];
                u.status = 'found';
                updateUserStatusUI(id);
                if(save) saveToDB();
                logMessage('success', `Traveler ${id}: Location "${name}" resolved via Hardcode.`);
                return;
            }

            // 2. Direct Lat/Lng Input Check
            const coordRegex = /^\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*$/;
            const match = normalizedName.match(coordRegex);
            if (match) {
                u.coords = { lat: parseFloat(match[1]), lng: parseFloat(match[3]) };
                u.status = 'found';
                updateUserStatusUI(id);
                if(save) saveToDB();
                logMessage('success', `Traveler ${id}: Location "${name}" resolved via Lat/Lng input.`);
                return;
            }

            // 3. GEMINI API GEOCODING
            u.status = 'searching';
            updateUserStatusUI(id); 
            logMessage('info', `Traveler ${id}: Attempting Geocoding for "${name}" via Gemini.`);

            const systemPrompt = "Act as a Geocoding service. Find the precise latitude (lat) and longitude (lng) for the given address or location name using real-time search grounding. Respond ONLY with a JSON object containing the 'lat' and 'lng' keys as floating-point numbers. Do not include any text, markdown, or explanation outside the JSON object.";
            const userQuery = `Find the latitude and longitude for the location: ${name}.`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "lat": { "type": "NUMBER", "description": "Latitude of the location." },
                            "lng": { "type": "NUMBER", "description": "Longitude of the location." }
                        }
                    }
                }
            };
            
            try {
                const coords = await fetchGeminiSimple(payload);
                if (typeof coords.lat === 'number' && typeof coords.lng === 'number' && (coords.lat !== 0 || coords.lng !== 0)) {
                    u.coords = { lat: coords.lat, lng: coords.lng };
                    u.status = 'found';
                    logMessage('success', `Traveler ${id}: Geocoding found coordinates ${coords.lat.toFixed(4)}, ${coords.lng.toFixed(4)}.`);
                } else {
                    u.coords = null;
                    u.status = 'error';
                    logMessage('error', `Traveler ${id}: Geocoding failed: LLM returned invalid or zero coordinates.`);
                }
            } catch (e) {
                u.coords = null;
                u.status = 'error';
                logMessage('error', `Traveler ${id}: Geocoding failed completely. Error: ${e.message}`);
            }
            
            updateUserStatusUI(id);
            if(save) saveToDB();
        }

        // --- SYNC ---
        function saveToDB() {
            if (!db || !state.userId || state.userId === 'guest') return;
            const ref = doc(db, "artifacts", appId, "users", state.userId, "sessions", "current");
            const syncData = { 
                timestamp: new Date(), 
                users: state.users.map(({ id, location, transport }) => ({ id, location, transport })),
                filters: state.filters, 
                optMode: state.optMode
            };
            setDoc(ref, syncData).catch(e=>logMessage('warning', `Firestore Save Error: ${e.message}`));
        }

        function setupSync() {
            if (!db || !state.userId || state.userId === 'guest') return;
            onSnapshot(doc(db, "artifacts", appId, "users", state.userId, "sessions", "current"), (snap) => {
                if (snap.exists()) {
                    const d = snap.data();
                    
                    state.filters = d.filters || state.filters;
                    state.optMode = d.optMode || state.optMode;
                    
                    if (d.users) { 
                        state.users = d.users.map(u => ({...u, coords: null, status: 'init'}));
                        renderUserList(); 
                        // Re-resolve locations after sync
                        logMessage('info', "Sync successful. Re-resolving locations from Firestore.");
                        Promise.all(state.users.map(u => resolveLocation(u.id, u.location, false))).then(() => updateMapMarkers());
                    }

                    renderFilters(); 
                    renderModeButtons(); 
                }
            });
        }

        // Start
        window.onload = init;
    </script>
</body>
</html>